[{"id":0,"href":"/docs/study/git/install-git-mac/","title":"Git 설치하기 - MAC","section":"Git","content":" Git 설치하기 (MAC) # Homebrew 설치하기 # 맥을 사용해 개발하는 사람이라면, Homebrew 의 존재를 모르는 사람은 드물 것이다. Git 역시 Homebrew 를 통해 Git 을 설치하고 관리할 수 있다.\nHomebrew 란? # Homebrew 는 Mac 용 패키지 관리자 프로그램으로 제공하는 이점은 크게 2가지가 있다.\nHomebrew 에 등록된 프로그램들을 단순한 명령어를 통해 쉽게 설치할 수 있다. 설치한 프로그램들을 Homebrew 가 관리하는 디렉토리 내에서 쉽게 관리할 수 있다. Mac 을 통해 개발하는 사람들에게 필수적인 프로그램이라고 할 수 있다.\nHomebrew 설치 명령어 # 터미널을 열고 아래 명령어를 작성하면 Homebrew 프로그램을 바로 설치할 수 있다.\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; (Homebrew 에 대한 좀 더 자세한 내용은 Homebrew 홈페이지 홈페이지에서 살펴보도록 하자.)\nGit 설치하기 # 터미널을 통해 아래 명령어를 사용하면 git 을 설치할 수 있다.\nbrew install git 정상적으로 설치가 완료됐다면, 아래 명령어를 입력할 경우 설치된 git 버전을 확인할 수 있다.\ngit --version // git version 2.xx.x "},{"id":1,"href":"/docs/study/java/","title":"Java","section":"Study","content":" Java # "},{"id":2,"href":"/docs/memory/2022/11/","title":"Nov","section":"2022","content":" 2022.11 # "},{"id":3,"href":"/docs/study/java/Lambda/Lambda1/","title":"람다식","section":"Lambda","content":" 람다식 Lambda Expression # 794 ~ 800p\n람다식 # Java 8 부터 제공되는 메서드를 하나의 식으로 표현하는 기능\n람다식을 사용하면 메서드의 이름과 반환값이 없어지므로 익명함수 Anonymous Function 라고 부르기도 한다.\n람다식의 사용방법을 예제로 살펴보자.\n람다식 X\nint[] arr = new int[5]; Arrays.setAll(arr, method()); int method() { return (int) (Math.random() * 5) + 1; } 람다식 O\nint[] arr = new int[5]; Arrays.setAll(arr, (i) -\u0026gt; (int)(Math.random() * 5) + 1); 위와 같이 람다식을 사용하면 따로 메서드를 선언-정의-호출해 줄 필요가 없다.\n규칙1. 매개변수 타입을 추론 가능할 경우 생략할 수 있다. # (int a, int b) -\u0026gt; a \u0026gt; b ? a : b (a, b) -\u0026gt; a \u0026gt; b ? a : b 규칙2. 표현식이 하나일 경우 대괄호는 생략할 수 있다. # (String name, int i) -\u0026gt; { System.out.println(name + \u0026#34;=\u0026#34; + i); } (String name, int i) -\u0026gt; System.out.println(name + \u0026#34;=\u0026#34; + i) 함수형 인터페이스 # 자바에서 모든 메서드는 클래스 내에 포함돼야 한다.\n람다식은 어떤 클래스에 포함돼있을까?\n사실 람다식은 메서드와 동등하지 않고, 익명 클래스의 객체와 동등하다.\n(int a, int b) -\u0026gt; a \u0026gt; b ? a : b new Object() { int max(int a, int b) { return a \u0026gt; b ? a : b; } } // max() 메서드는 임의의 메서드로 큰 의미는 없다. 그렇다면 만약 해당 객체를 임의의 참조변수에 저장한다면 어떻게 될까?\n타입 temp = (int a, int b) -\u0026gt; a \u0026gt; b ? a : b; 예를 들어, MyFunction 이라는 인터페이스가 정의돼 있다.\nInterface MyFunction { public abstract int max(int a, int b); } 이 인터페이스를 구현한 익명 클래스는 다음과 같이 생성해서 사용가능하다.\nMyFunction temp = new MyFunction() { @Override public int max(int a, int b) { return a \u0026gt; b ? a : b; } }; int num = temp.max(5, 3); 람다식이 어떤 방식으로 구현되고 있는지 이해가 되는가?\n하나의 인터페이스에 하나의 추상메서드를 정의해 람다식을 구현하는 방식은 자바의 규칙을 어기지 않는다.\n이렇게 람다식을 다루기 위한 인터페이스를 함수형 인터페이스 Functional Interface 라고 부른다.\n@FunctionalInterface interface MyFunction { public abstract int max(int a, int b); } 규칙1. 하나의 인터페이스에 하나의 추상메서드만 정의 가능하다. # 함수형 인터페이스의 경우 하나의 인터페이스에 하나의 추상메서드만이 정의될 수 있다.\n그래야 람다식과 인터페이스가 1대1 로 매핑될 수 있기 때문이다.\n규칙2. static 메서드와 default 메서드의 개수에는 제약이 없다. # static 과 default 키워드가 붙은 메서드의 개수에는 제약이 없다.\n핵심 정리 # 핵심은 메서드를 주고 받는 것이 아니라 함수형 인터페이스를 구현한 익명 객체를 주고 받는다는 것이다.\n@FunctionalInterface interface MyFunction { void run(); } class LamdaEx { static void excute(MyFunction f) { f.run(); } static MyFunction getMyFunction() { MyFunction f = new MyFunction() { @Override public void run() { System.out.println(\u0026#34;MyFunction run\u0026#34;); } }; return f; } static MyFunction getMyFunctionLamda() { MyFunction f = () -\u0026gt; System.out.println(\u0026#34;MyFunction Lamda run\u0026#34;); return f; } public static void main(String[] args) { MyFunction f1 = getMyFunction(); MyFunction f2 = getMyFunctionLamda(); f1.run(); f2.run(); excute(f1); } } MyFunction run MyFunction Lamda run MyFunction run "},{"id":4,"href":"/docs/study/git/","title":"Git","section":"Study","content":" Git # Git 의 시작 # Git 을 공부하면서 놀랐던 것은 리눅스 개발자로 알려진 리누스 토발즈 가 Git 을 개발했다는 사실이다.\n사진 1\n일반적으로 협업을 통해 하나의 프로젝트를 진행 때, 각자가 개발한 부분을 일일이 조합하는 것은 엄청난 비용이 필요하다. 그래서 많은 개발자들은 소스관리 혹은 버전관리 프로그램을 사용해왔다.\n리눅스 커널의 개발자들은 2002년부터 프로젝트를 관리하는 소스 관리 시스템(SCM)으로 비트키퍼를 사용했다. 그런데 비트키퍼의 저작권을 가지고 있던 래리 맥보이(Larry McVoy)는 앤드루 트리젤이 비트키퍼 프로토콜을 리버스 엔지니어링하여 소스풀러(SourcePuller)를 만들었다고 주장하면서, 비트키퍼의 자유 이용을 철회했다.\n그에 따라 많은 개발자들이 비트키퍼의 이용을 포기하게 되면서 2005년 4월부터 Git 개발이 시작되었다.\nGit 은 오픈소스 # Git 은 GNU GPL (General Public License) 을 따른다. GPL 을 따르는 소프트웨어들은 기본적으로 2차, 3차 창족물들에 대해 모든 소스코드를 공개하도록 돼있다. 즉, Git 은 오픈소스 소프트웨어이다.\nGit? Github? # 앞서 말했듯이 Git 은 오픈소스 소스관리 소프트웨어이다. 그렇다면 Github 는 무엇일까? Github 는 협업을 위해 각 개발자들이 짜놓은 소스코드들을 집약하고 관리할 수 있는 소스코드 저장소이다. (hub: 중심지, 중추)\nGithub 은 오픈소스가 아니다. # Github 에서 제공하는 서비스들은 Git 과 달리 오픈소스가 아니다.Github 는 GPL 이 아닌 Mit Licence 를 따른다. Mit License 따르는 소프트웨어는 무료 배포된 소스코드에 대한 2차 창작물들에 대해 공개 의무를 갖지 않는다.\n참고 # 참고로 오픈소스와 무료는 별개의 개념이다. Github 은 2018 년도에 마이크로 소프트 사에 의해 인수되었다. 참고문서 # 위키백과 - git "},{"id":5,"href":"/docs/study/java/Lambda/Lambda2/","title":"람다식의 타입과 형변환","section":"Lambda","content":" 람다식 Lambda Expression # 람다식의 장단점 # 장점 # 기존 익명함수 코드를 줄여 간단하게 작성 가능 가독성 증가 병렬 프로그래밍에 용이 단점 # 남용하면 코드를 이해하는데 어려움 까다로운 재귀 활용 및 디버깅 "},{"id":6,"href":"/docs/study/git/about-git/","title":"버전관리 시스템","section":"Git","content":" 버전관리 시스템 # 버전관리와 백업의 중요성 # 다음과 같은 상황을 가정해보자.\n개발자 A 가 file1.txt 를 작업 후 개발자 B 에게 보냈다. 개발자 B 는 개발자 A 에게 이 파일에 대해 수정 요청을 전달했다. 개발자 A 는 file1.txt 를 덮어써 수정 후 새로운 file1.txt 를 개발자 B 에게 보냈다. 개발자 B 는 이전의 file1.txt 가 낫다며, 다시 이전 버전의 파일을 개발자 A 에게 요청했다. 이 때, 개발자 A 와 B 모두 이전의 file1.txt 파일을 백업해놓지 않았다면 어떻게 될까? 이전 파일로 손쉽게 복구할 수 없을 것이다.\n이러한 문제로 인해 아래와 같이 버전별로 파일을 백업하고 관리해야 한다.\n개발자 A 가 file1-v1.txt 를 작업 후 개발자 B 에게 보냈다. 개발자 B 는 개발자 A 에게 이 파일에 대해 수정 요청을 전달했다. 개발자 A 는 file1-v1.txt 을 따로 백업하고 수정 후, 새로운 file1-v2.txt 를 개발자 B 에게 보냈다. 개발자 B 는 이전의 file1-v1.txt 가 낫다며, 다시 이전 버전의 파일을 개발자 A 에게 요청했다. 효율적인 백업의 필요성 # file-v1.txt\nabc abc file-v2.txt\nabc dfe 위와 같이 버전이 업로드될 때마다 새로운 파일의 형태로 백업하면 어떻게 될까?\n새로운 파일을 생성해 같은 데이터를 통으로 복사하는 시간적 비용이 들 수 있다. 경우에 따라 버전이 달라져도 abc 라는 데이터는 그대로 유지되는 경우 중복된 데이터인 abc 는 용량 낭비를 초래할 것이다. 버전관리 시스템, VCS (Version Control System) # 버전관리 시스템은 버전관리와 비효율적인 백업 문제를 해결해줄 수 있다.\n하나의 파일에서 수정을 한다. 수정사항을 체크해 버전을 관리한다. (ex. 수정사항이 생길때 마다 버전을 1씩 증가) 필요에 따라 이전 버전의 데이터로 돌아간다. 버전관리 시스템의 문제점 # 단, 버전관리 시스템에도 문제가 있다.\n바이러스에 노출되면 파일 전체가 날아갈 수 있다. 협업이 불가능하다. 중앙집중형 버전관리 시스템, CVCS # 중앙집중형 버전관리 시스템의 경우, 버전 관리용 중앙 컴퓨터 개념을 도입해 아래와 같은 방식으로 협업이 가능하다.\n개발자 A 는 file1.txt (ver1) 를 작업한다. file1.txt (ver1) 을 중앙 컴퓨터에 업로드한다. 개발자 B 는 C 컴퓨터에 저장된 file1.txt (ver1) 를 다운로드해 작업한다. file1.txt (ver2) 을 중앙 컴퓨터에 업로드한다. 핵심은 버전에 대한 history 를 로컬에 저장된 파일은 갖고 있지 않다는 점이다. 버전에 대한 history 는 중앙 컴퓨터에서 관리하는 파일만 갖고 있다.\n중앙집중형 버전관리 시스템의 문제점 # 하지만 CVCS 에도 문제점이 있는데,\n협업 시, 소통을 원할히 하지 않으면 수정된 데이터가 날아갈 수 있다. 예를 들어, file1.txt (ver2) 가 업로드된 것을 모르고 개발자 A가 file1.txt (ver1) 을 재업로드할 수 있다.\n중앙 컴퓨터 혹은 컴퓨터에 저장된 파일에 바이러스가 걸리면 파일 전체가 날아갈 수 있다.\n분산형 버전관리 시스템, DVCS # 중앙집중형 버전관리 시스템이 버전에 대한 history 를 중앙 컴퓨터에 저장된 파일만 갖고 것과 달리, 분산형 버전관리 시스템은 로컬에 저장된 파일도 history 를 갖고 있다.\n이런 방식을 채택하면 중앙 저장소에 있는 파일에 문제가 생기더라도 여러 작업자가 history 를 유지한 파일을 갖고 있기 때문에 파일의 보존이 가능해진다.\n"},{"id":7,"href":"/posts/1/","title":"대망의 블로그 첫 게시글","section":"etc","content":" 일 벌리기 선수 # 개발 공부를 한지도 벌써 약 5개월정도 지난 지금.. 처음보다 아는 것은 많은 것 같은데, 뭐 하나 제대로 알고 있는 것이 없다는 생각이 들었다. 🫠 여러 곳에 흩어져 있는 정리본들을 하나하나 다시 정리하고 공부할 필요성을 느꼈다.\n처음엔 그냥 해오던 것처럼 Notion 이나 Bear 같은 개인 공간에 정리할까 했지만 이왕 공부하고 정리하는 김에 남들에게 보여줄 수 있는 공간에 정리하면 좋겠다 싶었다.\n지나치지 못하고 이렇게 또 일을 만들어버렸다. 😂\nJekyll? Hugo? # 무슨 블로그가 좋을까 고민을 했다.\n일단 티스토리와 velog는 쓰고 싶지 않았다. 예전에 잠깐 블로그를 찍먹해봤을때 티스토리는 뭔가 조잡한 느낌이었고, velog는 너무 간단해서 오히려 불편했다.\n그렇다면 이참에 Github 를 이용해 블로그와 코드들을 통합관리해보자! 하는 생각에 Github 를 이용해 블로그를 개설키로 했다.\n조금 찾아보니 Hugo 와 Jekyll 을 이용해 블로그를 개설하는 방법이 대표적인 것 같았다.\nJekyll 은 github 의 CEO 가 만든 Ruby 기반의 툴로 좀 더 공식적인(?) 느낌이 있었다. 조금만 찾아보니 많은 사람들이 빌드 속도를 이유로 Hugo 를 사용하더라. Hugo 는 Go 기반의 툴로 빌드 속도가 Jekyll 에 비해 훨씬 빠르다고 한다.\n이러한 이유로 Hugo 를 선택했다.\n뻘짓의 연속 # 처음엔 금방 할 줄 알았지만 착각이었다. 🤬\n블로그 적당히 보고 따라하면 될 줄 알았다. 하지만 이유 모를 에러 속에서 허우적댔고 블로그 개설을 겨우 마친 뒤에는\n까다로운 사용방법이 나를 기다리고 있었다.\n배보다 배꼽이 더 커지는 불상사가..\n원래 첫 게시글로 나와 같은 상황에 직면할 사람들을 위해 Hugo 적용 방법을 게시하고 싶었지만,\n이것저것 들여다본다고 시간이 너무 많이 지나서 첫 글은 조금 급하게 마무리한다.\n시간적 여유가 있을 때 꼭 올리도록 하겠다 🙆‍♂️\n해결해야 될 것들 # 날짜 설정이 한국기준이 아닌지, 오늘 날짜만 적용이 되지 않는다.. 메인 페이지에서 댓글창 빼고 싶다.. "}]